#include <sequence/tuning.hpp>

#include <cmath>
#include <filesystem>
#include <fstream>
#include <iomanip>
#include <sstream>
#include <stdexcept>
#include <string>
#include <vector>

namespace sequence
{

auto from_scala(std::filesystem::path const &scala_file) -> Tuning
{
    auto file = std::ifstream{scala_file};

    if (!file)
    {
        throw std::runtime_error("Could not open file: " + scala_file.string());
    }

    auto tuning = Tuning{};
    auto &intervals = tuning.intervals;
    intervals.push_back(0.f); // The first interval is always 0

    auto line = std::string{};
    bool description_line_skipped = false;
    bool notes_line_read = false;
    int note_count = 0;

    while (std::getline(file, line))
    {
        if (line.empty() || line[0] == '!') // Ignore comments and empty lines
        {
            continue;
        }

        if (!description_line_skipped)
        {
            description_line_skipped = true; // Skip the first non-comment line
            continue;
        }

        if (!notes_line_read)
        {
            auto ss = std::stringstream{line};
            ss >> note_count;
            if (!ss || note_count < 0)
            {
                throw std::runtime_error("Invalid number of notes.");
            }
            notes_line_read = true;
            continue;
        }

        if (note_count == 0) // All notes have been read
        {
            break;
        }

        // Parse the pitch value
        if (line.find('/') != std::string::npos) // Ratio
        {
            auto pos = line.find('/');
            try
            {
                auto numerator = std::stof(line.substr(0, pos));
                auto denominator = std::stof(line.substr(pos + 1));
                if (numerator <= 0.f || denominator <= 0.f)
                {
                    throw std::runtime_error(
                        "Negative ratio or zero denominator is not allowed.");
                }
                // Ratio to Cents
                intervals.push_back(1200.f * std::log2(numerator / denominator));
            }
            catch (...)
            {
                throw std::runtime_error("Invalid ratio: " + line);
            }
        }
        else if (line.find('.') != std::string::npos) // Cents
        {
            auto ss = std::stringstream{line};
            auto cents = 0.f;
            ss >> cents;
            if (!ss)
            {
                throw std::runtime_error("Invalid cents value.");
            }
            intervals.push_back(cents);
        }
        else // Integer ratio
        {
            try
            {
                auto numerator = std::stoll(line);
                if (numerator <= 0)
                {
                    throw std::runtime_error("Negative ratio is not allowed.");
                }
                intervals.push_back(1200.f * std::log2(static_cast<float>(numerator)));
            }
            catch (...)
            {
                throw std::runtime_error("Invalid ratio.");
            }
        }

        --note_count;
    }

    if (note_count > 0)
    {
        throw std::runtime_error("Not enough pitch values in the file.");
    }

    tuning.octave = intervals.back();
    intervals.pop_back();

    return tuning;
}

auto to_scala(Tuning const &tuning, std::filesystem::path const &file,
              std::string const &description) -> void
{
    std::ofstream ofs(file);

    if (!ofs.is_open())
    {
        throw std::runtime_error{"Could not open file for writing"};
    }

    // First is the filename and description comments
    ofs << "! " << file.filename().string() << "\n! Tuning generated by XenSequencer\n";

    // The first non-comment line is a description of the tuning
    ofs << description << "\n";

    // The second non-comment line is the number of notes per octave
    ofs << tuning.intervals.size() << "\n!\n";

    // Then come the intervals, one per line. Skip the first entry, which is always 0
    // set up stream to output 6 decimal places
    ofs << std::fixed << std::setprecision(6);
    for (auto i = std::size_t{1}; i < tuning.intervals.size(); ++i)
    {
        ofs << tuning.intervals[i] << "\n";
    }

    // Scala files usually end with the octave ratio
    ofs << tuning.octave << "\n";
}

} // namespace sequence